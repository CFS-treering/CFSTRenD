
# # Load points data
# dir.src <- "U:/Canada_Tree-Ring_Data/Shared/LFC process/analysis/detrending species Apr2024/det_Lbai by spc"
#
# f.det.lst <- list.files(path = dir.src, full.names = TRUE,  pattern = "_detrend_spc.csv$")
#
# fn.lst = f.det.lst[1:2]
# # reading all data involved



#' Read and Process Tree-Ring Series Data
#'
#' Reads a list of CSV/TSV files containing tree-ring series data, filters by year range,
#' limits values to a specified range, reshapes the data into wide format, and combines
#' all series into a single data.table.
#'
#' @param fn.lst A character vector of file paths to be read. Each file should be readable by `fread()`
#'   and contain at least the specified metadata and variable columns.
#' @param year.span A numeric vector of length two specifying the start and end years (inclusive).
#'   Default is \code{c(1801, 2017)}.
#' @param var.name A character string specifying the name of the variable to extract and reshape.
#'   Default is \code{"ratio.Bai.bv.o_p"}.
#' @param val.lim A numeric vector of length two specifying the lower and upper bounds for the variable values.
#'   Values outside this range will be clipped. Default is \code{c(-100, 100)}.
#' @param cols.meta A character vector specifying the required metadata columns in the input files.
#'   These columns are preserved in the output. Default is \code{c("uid_tree", "uid_site", "longitude", "latitude", "species", "year")}.
#'
#' @return A list with of class \code{"cfs_mapping"}, the first is a \code{data.table} , reshaped to wide format with one row per tree
#'   and year values in columns prefixed with \code{"X"}. Includes all metadata columns (except "year") and the
#'   selected variable across years. the second is a string for var.name
#'
#' @examples
#' \dontrun{
#' files <- list.files("data/input", full.names = TRUE, pattern = "\\.csv$")
#' dt <- read_series(files)
#' }


#' @export read_series
read_series <- function(fn.lst, year.span = c(1801, 2017),
                        var.name = "ratio.Bai.bv.o_p", val.lim = c(-100, 100),
                        cols.meta = c("uid_tree", "uid_site", "longitude", "latitude", "species", "year")) {

  dt.list <- lapply(fn.lst, function(fname) {
    dt <- tryCatch(fread(fname), error = function(e) NULL)

    if (is.null(dt) || !all(c(cols.meta, var.name) %in% names(dt))) return(NULL)

    dt <- dt[, c(cols.meta, var.name), with = FALSE]

    # Filter year
    dt <- dt[year >= year.span[1] & year <= year.span[2]]

    # Limit values
    dt[, (var.name) := pmin(pmax(get(var.name), val.lim[1]), val.lim[2])]

    # Reshape to wide
    fml <- stats::as.formula(paste(paste(cols.meta[cols.meta != "year"], collapse = " + "), "~ year"))
    dt.wide <- dcast(dt, formula = fml, value.var = var.name)

    return(as.data.table(dt.wide))
  })

  # Remove NULLs from list (in case some files were skipped)
  dt.list <- dt.list[lengths(dt.list) > 0]

  # Now bind all together
  dt.w <- rbindlist(dt.list, use.names = TRUE, fill = TRUE)

  # Rename and reorder columns
  year_cols <- setdiff(names(dt.w), cols.meta)
  setcolorder(dt.w, c(cols.meta[cols.meta != "year"], sort(year_cols)))
  setnames(dt.w, old = sort(year_cols), new = paste0("X", sort(year_cols)))

  result <- list(dt.w = dt.w, var.name = var.name)
  class(result) <- c("cfs_mapping", class(result))
  return(result)
}


#' Interpolate and Map Tree-Ring Data
#'
#' This function performs inverse distance weighting (IDW) interpolation
#' of tree-ring data across a spatial grid, either for all species combined
#' or by individual species. It generates yearly interpolated raster maps
#' over a user-defined extent or the extent of the input data.
#'
#' @param data A \code{cfs_mapping} object produced by \code{read_series()}.
#' @param year.span Numeric vector of length 2 giving the range of years to include.
#' @param extent.lim Optional numeric vector defining the spatial extent
#'   (\code{c(xmin, xmax, ymin, ymax)}). If \code{NULL}, the extent is
#'   determined from the input data.
#' @param grid.step Numeric value specifying the grid spacing in degrees.
#' @param by.spc Logical; if \code{TRUE}, maps are generated by species;
#'   if \code{FALSE}, all species are combined.
#'
#' @return An object of class \code{cfs_gif}, a list of interpolated raster layers
#'   by species and year.
#'
#' @examples
#' \dontrun{
#' data <- read_series("path/to/file.rwl")
#' maps <- CFS_mapping(data, year.span = c(1900, 2000), grid.step = 0.5)
#' }

#' @export
#'


CFS_mapping <- function(data, year.span = c(1801, 2017),
                        extent.lim = NULL, grid.step = 0.1,
                        by.spc = FALSE) {

  #----------------------------
  # Input checks
  #----------------------------
  if (!inherits(data, "cfs_mapping")) {
    stop("Input data must be the result of read_series() and of class 'cfs_mapping'")
  }

  check_optional_deps()

  data <- data$dt.w

  # Add species column if needed
  if (by.spc) {
    data[, species.inuse := species]
  } else {
    data$species.inuse <- "all.spp"
  }

  #----------------------------
  # Identify year and non-year columns
  #----------------------------
  year_cols <- grep("^\\d+$", str_sub(names(data), 2, -1), value = TRUE)
  non_year_cols <- setdiff(names(data), paste0("X", year_cols))

  val.years <- intersect(year_cols, as.character(year.span[1]:year.span[2]))
  data.yr <- data[, c(non_year_cols, paste0("X", val.years)), with = FALSE]

  #----------------------------
  # Create grid (Canada extent or user-defined)
  #----------------------------
  canada_ext <- if (is.null(extent.lim)) {
    raster::extent(
      min(data$longitude), max(data$longitude),
      min(data$latitude), max(data$latitude)
    )
  } else {
    raster::extent(extent.lim)
  }

  grid <- expand.grid(
    longitude = seq(from = canada_ext@xmin, to = canada_ext@xmax, by = grid.step),
    latitude  = seq(from = canada_ext@ymin, to = canada_ext@ymax, by = grid.step)
  )
  grid$grid_cell <- seq_len(nrow(grid))
  sp::coordinates(grid) <- ~longitude + latitude
  sp::gridded(grid) <- TRUE

  #----------------------------
  # Run over all species using map
  #----------------------------
  spc.lst <- sort(unique(data$species.inuse))

  results_list.spc <- purrr::map(spc.lst, function(spc.i) {
    dt.spc.i <- data.yr[species.inuse == spc.i]

    # remove columns with only NA
    setDF(dt.spc.i)
    dt.spc.i <- dt.spc.i[, colSums(!is.na(dt.spc.i)) > 0, drop = FALSE]
    setDT(dt.spc.i)

    # Identify year columns left
    cols <- setdiff(names(dt.spc.i), non_year_cols)
    names(cols) <- str_sub(cols, 2)  # strip "X" to keep year

    # Run over years using map
    results_list.ispc <- purrr::map(cols, function(col) {
      yr <- as.numeric(str_sub(col, 2))

      current_data <- dt.spc.i[!is.na(dt.spc.i[[col]]),
                               c("longitude", "latitude", col), with = FALSE]

      if (nrow(current_data) == 0) return(NULL)  # skip empty years

      sp::coordinates(current_data) <- ~longitude + latitude

      idw_model <- gstat::idw(
        as.formula(paste(col, "~1")),
        locations = current_data,
        newdata   = grid,
        idp = 2,
        nmax = 100
      )

      # res <- raster::raster(idw_model)
      # names(res) <- yr
      # return(res)
      raster::raster(idw_model)
    })

    names(results_list.ispc) <- names(cols)
    results_list.ispc
  })

  names(results_list.spc) <- spc.lst
  class(results_list.spc) <- c("cfs_gif", class(results_list.spc))
  return(results_list.spc)
}



#' Generate mapped spatial-temporal plots
#'
#' This function interpolates and visualizes tree ring data (e.g., BAI growth change) across space and time
#' using inverse distance weighting (IDW). Outputs can include maps in PNG and GIF formats, interpolated raster
#' files in GeoTIFF format, and gridded values in CSV format.
#'
#' @param data A data.table object of class \code{cfs_mapping}, typically generated by \code{\link{read_series}}.
#' @param year.span A numeric vector of length two specifying the start and end years for analysis. Default is \code{c(1801, 2017)}.
#' @param extent.lim Optional. A numeric vector specifying map extent in the form \code{c(xmin, xmax, ymin, ymax)}. If \code{NULL}, extent is computed from the data.
#' @param grid.step A numeric value specifying the resolution (in degrees) of the interpolation grid. Default is \code{0.1}.
#' @param animation_fps Frames per second for the animated GIF output. Default is \code{1.0}.

#' @param by.spc Logical. If \code{TRUE}, runs separately for each species. Default is \code{FALSE}.
#' @param parms.out Character vector specifying the types of outputs to generate. Valid values are:
#'   \code{"csv"}, \code{"tif"}, \code{"png"}, and \code{"gif"}.
#' @param dir.out A character string specifying the directory where outputs will be saved. Required if \code{parms.out} is not empty.
#' @param data.crs Character string specifying the CRS (coordinate reference system) for spatial outputs. Default is WGS84.
#' @param ... Additional parameters passed to the function.
#'
#' @return This function does not return a value but saves outputs to disk depending on the options selected in \code{parms.out}.
#'   Output includes:
#'   \itemize{
#'     \item PNG maps of interpolated tree growth
#'     \item Animated GIFs showing change over time
#'     \item Raster GeoTIFFs of interpolated values
#'     \item CSV files of gridded predicted values
#'   }
#'
#' @details
#' The function performs spatial interpolation using IDW and masks outputs to Canada and boreal zones using shapefiles.
#' The elevation layer and mask files are internal to the \code{growthTrendR} package and used for contextual mapping.
#'
#' PNG and GIF outputs are generated using \code{magick}, raster outputs via \code{terra}, and interpolation via \code{gstat}.
#'
#' @section File Outputs:
#' When parms.out is specified, the following directory structure is created:
#' \itemize{
#'   \item \strong{png/}: Individual PNG files for each species and year
#'   \item \strong{gif/}: Animated GIF files for each species
#'   \item \strong{csv/}: CSV files with annual data for each species
#'   \item \strong{tif/}: GeoTIFF files for each species and year
#' }
#'
#' @seealso
#' \code{\link{CFS_mapping}} for preparing input data
#'
#' @examples
#' \dontrun{
#' # Basic usage - return animated GIFs
#' gif_results <- plot_mapping(cfs_data)
#'
#' # Generate all output formats
#' plot_mapping(cfs_data,
#'               animation_fps = 2.0,
#'               parms.out = c("png", "gif", "csv"),
#'               dir.out = "output_folder")
#'
#'
#' # Custom animation speed and plot parameters
#' plot_mapping(cfs_data,
#'               animation_fps = 0.5,
#'               parms.out = "gif",
#'               dir.out = "slow_gifs")
#' }
#'

#' @export


plot_mapping <- function(data, year.span = c(1801,2017),
                     # cols.meta = c("uid_tree", "uid_site", "longitude", "latitude", "species", "year"),
                       extent.lim = NULL, grid.step = 0.1 , animation_fps = 1.0,
                     # png.text = list(text1= "BAI Annual Growth Change -", text_bott = "Created by Martin P. Girardin, Canadian Forest Service (2025)" , text_side = "Growth Change (%)"),
                     by.spc = FALSE, parms.out = c("", "csv","tif","png", "gif"), dir.out= NULL,
                     data.crs = "+proj=longlat +datum=WGS84 +no_defs", ...
                     ){

  check_optional_deps()

  if (!inherits(data, "cfs_mapping")) stop("please check the input of data, make sure it's the result of read_series() function")
  if (length(setdiff(parms.out, c("csv","tif","png", "gif"))) > 0) stop('please check parms.out, only "csv","tif","png", "gif" are supported' )
  if (is.null(dir.out) & !is.null(parms.out)) stop("please specify the output directory (dir.out) ")
  if (by.spc == TRUE) dir.out <- file.path(dir.out, "by_spc")
  if (!dir.exists(dir.out)) dir.create(dir.out, recursive = TRUE)
  data <- data$dt.w

  if (by.spc == TRUE)  data[, species.inuse:= species] else
    data$species.inuse <- "all.spp"
  year_cols <- grep("^\\d+$", str_sub(names(data), 2, -1), value = TRUE)

  # Get non-year columns
  non_year_cols <- setdiff(names(data), paste0("X", year_cols))
  val.years <- intersect(year_cols, as.character(year.span[1]:year.span[2]))
  data.yr <- data[ ,c(non_year_cols, paste0("X", val.years)), with = FALSE]


  if (is.null(extent.lim)){
  # Create a grid covering Canada
  canada_ext <- extent(min(data$longitude), max(data$longitude),
                       min(data$latitude), max(data$latitude))}else
   canada_ext <- extent(extent.lim)


  grid <- expand.grid(
    longitude = seq(from = canada_ext@xmin, to = canada_ext@xmax, by = grid.step),
    latitude = seq(from = canada_ext@ymin, to = canada_ext@ymax, by = grid.step)
  )

  grid$grid_cell <- 1:nrow(grid)
  sp::coordinates(grid) <- ~longitude+latitude
  sp::gridded(grid) <- TRUE
  final_df <- as.data.frame(grid)

  ncells_total <- nrow(final_df)

  elevation_file <- system.file("extdata/Mapping/Canada120s.tif", package = "growthTrendR")

  # Read elevation and shapefiles
  elevation <- rast(elevation_file)


  # using the figshare that martin provided to avoid big extdata
  # the reference is here https://doi.org/10.6084/m9.figshare.30005473.v1 (Martin 2025-10-01) then redirect to
  # https://figshare.com/articles/dataset/Spatially_detailed_tree-ring_analysis_throughout_Canada/30005473
  # the true url is by right clicking download button to copy link address for the file
  # url <- "https://figshare.com/ndownloader/files/57487996"


  boreal_mask <- get_boreal_mask("https://figshare.com/ndownloader/files/57487996")
  canada_mask <- sf::st_read(system.file("extdata/Mapping/province.shp", package = "growthTrendR"))

  spc.lst <- sort(unique(data$species.inuse))
    # run over all species
  results_list.spc <- lapply(spc.lst, function(spc.i){
    dt.spc.i <- data.yr[species.inuse == spc.i]
    # remove the columns with NA only
    setDF(dt.spc.i)
    dt.spc.i <- dt.spc.i[, colSums(!is.na(dt.spc.i)) > 0]
    setDT(dt.spc.i)
    # run over year
    lst <- list()
    cols <-setdiff(names(dt.spc.i), non_year_cols)
    names(cols) <- str_sub(cols, 2)

    results_list.ispc <- lapply(cols, function(col) {
      yr <- as.numeric(str_sub(col,2))

      current_data <- dt.spc.i[!is.na(dt.spc.i[[col]]), c("longitude", "latitude", col), with = FALSE]

      # Ensure spatial coordinates
      sp::coordinates(current_data) <- ~longitude + latitude
      # sp::coordinates(grid) <- ~longitude + latitude

      idw_model <- gstat::idw(as.formula(paste(col, "~1")),
                       locations = current_data,
                       newdata = grid,
                       idp = 2,
                       nmax = 100)

      df.idw <- cbind( year = yr, as.data.table(idw_model)[, -"var1.var"])
       r <- raster(idw_model)

       # # mask
       # r_crop <- crop(r, canada_mask_proj)
       # r_mask <- mask(r_crop, canada_mask_proj)
       if (any(str_detect(parms.out, "tif")) == TRUE) {

         dir.out1<- file.path(dir.out, "tif")
         if (!dir.exists(dir.out1)) dir.create(dir.out1)
         writeRaster(r,
                     filename = file.path(dir.out1,
                                          paste0(spc.i, " ","tree_rings_", yr, ".tif")),
                     format = "GTiff",
                     overwrite = TRUE)
       }
       crs(r) <- data.crs
       boreal_mask_proj <- sf::st_transform(boreal_mask, data.crs)
       canada_mask_proj <- sf::st_transform(canada_mask, data.crs)
       r_boreal <- mask(rast(r), vect(boreal_mask_proj))
       r_masked <- mask(r_boreal, vect(canada_mask_proj))  # Second masking step with Canada



       # Prepare output path if PNG is requested
       output_png <- NULL
       if (any(str_detect(parms.out, "png"))) {
         dir.png <- file.path(dir.out, "png")
         dir.create(dir.png, showWarnings = FALSE, recursive = TRUE)
         output_png <- file.path(dir.png, paste0(spc.i, " tree_rings_", yr, ".png"))
       }

       # Call the function once, with or without output path
       p <- plot_tree_ring_map(r_masked, elevation, yr, out.png = output_png, ...)

       # Save output if GIF is requested
       if (any(str_detect(parms.out, "gif"))) {
         lst$png <- p
       }



      # Return result with year attached in csv per species with all year
      if (any(str_detect(parms.out, "csv"))) {
        cat("Adding data for year:", col, "\n")
        values_vector <- terra::values(r_masked)
        ncells_total <- ncell(r_masked)
        coords <- xyFromCell(r_masked, 1:ncells_total)
        final_df <- data.frame(grid_cell = 1:ncells_total, X = coords[, "x"], Y = coords[, "y"])
        if (length(values_vector) == ncells_total) {
          final_df.ispc <- data.frame(final_df, year = yr, var1.pred = values_vector)
        } else {
          temp_vec <- rep(NA, ncells_total)
          non_na_indices <- which(!is.na(values_vector))
          if (length(non_na_indices) > 0) {
            valid_indices <- non_na_indices[non_na_indices <= ncells_total]
            temp_vec[valid_indices] <- values_vector[valid_indices]
          }
         final_df.ispc <- data.frame(final_df, year = yr, var1.pred = temp_vec)
        }
       final_df.clean <- final_df.ispc[!is.na(final_df.ispc[,"var1.pred"]),]


       lst$df.idw <- final_df.clean

      }

     if (length(lst) > 0) return(lst)
    }
    ) # year loop end



    if (any(str_detect(parms.out, "csv")) == TRUE) {
      # Return result with year attached in csv per species with all year
      df.idw.ispc <- rbindlist(lapply(results_list.ispc, `[[`, "df.idw"), fill = TRUE)
      df.test <- rbindlist(lapply(results_list.ispc, `[[`, "df.idw.comp"), fill = TRUE)

      df.idw.ispc.all <- rbindlist(lapply(results_list.ispc, `[[`, "df.idw.all"), fill = TRUE)
      # Optional: reshape to wide format
      df.idw.ispc.wide <- dcast(df.idw.ispc, grid_cell ~ year, value.var = "var1.pred")
      df.idw.ispc.wide<- merge(final_df, df.idw.ispc.wide, by = "grid_cell", all.y = TRUE)
      dir.csv<- file.path(dir.out, "csv")
      if (!dir.exists(dir.csv)) dir.create(dir.csv)
      utils::write.csv(df.idw.ispc.wide, file = file.path(dir.csv, paste0(spc.i, " ", " by degree-", grid.step," y",  year.span[1], "-", year.span[2], ".csv")), row.names = FALSE, na = "")
      # utils::write.csv(df.idw.ispc.all, file = file.path(dir.csv, paste0(spc.i, " ", " by degree-", grid.step," y",  "idw.model", ".csv")), row.names = FALSE, na = "")

    }
      years <- names(results_list.ispc)  # or however you store years
     img_list <- unlist(lapply(results_list.ispc[order(as.numeric(years))], `[[`, "png"))

     gif_imgs <- magick::image_read(img_list)
     gif_animated <- magick::image_animate(gif_imgs, fps = animation_fps)

       if (any(str_detect(parms.out, "gif")) == TRUE) {

         dir.out1<- file.path(dir.out, "gif")
         if (!dir.exists(dir.out1)) dir.create(dir.out1)
         # img_list <- unlist(lapply(results_list.ispc, `[[`, "png"))
         # img_list <- sort(img_list)


         gif_animated %>%
           magick::image_write(file.path(dir.out1, paste0(spc.i, " ","tree_rings_animation y", year.span[1],"-", year.span[2], ".gif")))
       }
     return(gif_animated)

})# species lapply end
  names(results_list.spc) <- spc.lst
return(results_list.spc)
  } # function end



#' Plot Tree-Ring Growth Map with Elevation
#'
#' Creates a static PNG map overlaying tree-ring growth changes on top of a grayscale elevation raster,
#' including a customized color legend and annotation.
#'
#' @param tree_ring_raster A raster object containing the tree-ring growth change values (e.g., BAI ratio).
#' @param elevation_raster A raster object representing elevation data for background shading.
#' @param year Integer. The year to display in the map title.
#' @param out.png Optional. File path for saving the PNG map. If `NULL`, a temporary file is created and returned.
#' @param png.text A named list of character strings used to annotate PNG maps. Elements include:
#'   \itemize{
#'     \item \code{text_top}: Main top title (e.g., "BAI Annual Growth Change -")
#'     \item \code{text_bott}: Bottom caption (e.g., author or data source)
#'     \item \code{text_side}: Legend or axis label (e.g., "Growth Change (%)")
#'   }
#'
#' @return The file path of the created PNG image if `out.png` is not provided.
#' @keywords internal
#' @noRd

plot_tree_ring_map <- function(tree_ring_raster, elevation_raster, year, out.png = NULL,
                               png.text = list(text_top= "BAI Annual Growth Change -", text_bott = "Created by Martin P. Girardin, Canadian Forest Service (2025)" , text_side = "Growth Change (%)")) {

  png.text <- utils::modifyList(list(text_top= "BAI Annual Growth Change -", text_bott = "Created by Martin P. Girardin, Canadian Forest Service (2025)" , text_side = "Growth Change (%)"), png.text)
  # Determine output file
  if (!is.null(out.png)) {
    output_file <- out.png
  } else {
    output_file <- tempfile(fileext = ".png")
  }

  png(output_file, width = 2500, height = 1300, res = 300)
  par(mfrow = c(1, 1))
  layout(matrix(c(1, 2), ncol = 2), widths = c(4, 1))
  par(mar = c(4, 4, 1, 3))

  if (!identical(crs(elevation_raster), crs(tree_ring_raster))) {
    elevation_raster <- terra::project(elevation_raster, tree_ring_raster)
  }
  elevation_raster <- raster::crop(elevation_raster, tree_ring_raster)
  elevation_raster[elevation_raster < 1] <- NA

  terra::plot(elevation_raster, col = gray.colors(100, start = 0.8, end = 0.3), legend = FALSE,
       main = paste(png.text[["text_top"]], year), axes = TRUE)

  r_clipped <- raster::clamp(tree_ring_raster, lower = 0.5, upper = 1.5, values = TRUE)
  terra::plot(r_clipped,
       col = colorRampPalette(c("red", "yellow", "green", "blue"))(100),
       alpha = 0.6,
       add = TRUE,
       legend = FALSE)
  grid()
  mtext(png.text[["text_bott"]],
        side = 1, line = 3, adj = 0, cex = 0.8)

  par(mar = c(5, 0, 3, 3))
  raster::plot(c(0, 1), c(0.3, 1.7), type = "n", axes = FALSE, xlab = "", ylab = "")

  cols <- colorRampPalette(c("darkred", "red", "yellow", "green", "blue"))(100)
  breaks <- seq(0.5, 1.5, length.out = length(cols) + 1)

  for(i in 1:length(cols)) {
    rect(0.1, breaks[i], 0.4, breaks[i + 1], col = cols[i], border = NA)
  }

  tick_positions <- seq(0.5, 1.5, by = 0.1)
  tick_labels <- paste0((tick_positions - 1) * 100)
  axis(4, at = tick_positions, labels = tick_labels, las = 1, cex.axis = 0.8, pos = 0.5)
  mtext(png.text[["text_side"]], side = 4, line = 1.5, cex = 1.2)

  dev.off()

  # Return the output file path
  if (is.null(out.png)) return(output_file)
}


#' Download and Read Boreal Mask Shapefile
#'
#' Downloads the North American Boreal forest shapefile from Figshare and
#' reads it as an sf object. This is an internal function.
#'
#' @param url Character string. URL to download the shapefile zip from.
#'   Defaults to the Figshare repository URL.
#' @return An sf object containing the boreal mask polygon(s)
#' @noRd
#' @keywords internal
get_boreal_mask <- function(url) {

  # Download zip file
  temp_zip <- tempfile(fileext = ".zip")
  temp_dir <- tempfile()

  res <- httr::GET(
    url,
    httr::write_disk(temp_zip, overwrite = TRUE),
    httr::config(followlocation = TRUE),
    httr::add_headers("User-Agent" = "Mozilla/5.0"),
    httr::timeout(300)
  )

  if (res$status_code != 200) {
    stop("Download failed with status code: ", res$status_code)
  }

  # Extract and read shapefile
  utils::unzip(temp_zip, exdir = temp_dir)
  shp_file <- list.files(temp_dir, pattern = "\\.shp$",
                         recursive = TRUE, full.names = TRUE)[1]

  if (is.na(shp_file)) {
    stop("No shapefile found in downloaded archive")
  }

  boreal_mask <- sf::st_read(shp_file, quiet = TRUE)

  # Cleanup
  unlink(temp_zip)
  unlink(temp_dir, recursive = TRUE)

  return(boreal_mask)
}



























