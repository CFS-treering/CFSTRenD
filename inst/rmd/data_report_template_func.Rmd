---
  # title: "vignette_CFSTRenD"
title: "data summary report"

date: "`r Sys.Date()`"
output:
  html_document:
  theme: flatly
highlight: tango

params:
  robj: NULL
  usage: NULL


# toc: true
# toc_depth: 4            # Define the depth of the TOC (increase as needed)
# toc_float:
#   collapsed: TRUE      # Whether the TOC starts collapsed
# smooth_scroll: true   # Smooth scrolling when a TOC entry is clicked
# 
# fontsize: 12pt              # Set font size
# linkcolor: blue             # Hyperlink color (for PDF output)
# subtitle: "generated by R Markdown"

# knitr:
#   opts_chunk: 
#     echo: false
    
    
---
```{r setup, include=FALSE}
# This chunk sets global options to hide all R code from appearing in the output

knitr::opts_chunk$set(echo = FALSE)
library(data.table)
library(CFSTRenD)
library(gt)
library(htmltools)
library(stringr)
# library(ggplot2)
# library(sf)

# read ring measurement
 # samples69.o <- fread(system.file("extdata", "samples69.csv", package = "CFSTRenD"))
 #  samples69.trt <- CFS_format(data = list(samples69.o, 39:140), usage = 1, out.csv = NULL)
 #  
load("C:/Users/xjguo/OneDrive - NRCan RNCan/driveP/2025_/demand/dominique/rwl.all.Rdata")

# samples69_long <- merge(robj$tr_all_wide[, c("uid_site", "site_id", "species", "uid_tree", "uid_sample", "uid_radius")], 
   # tr_long$tr_7_ring_widths, by = "uid_radius")




# # rename to the reserved column name
# samples69_long<- copy(tr_7)
# setnames(samples69_long, c("uid_radius", "year", "rw_mm"), c("SampleID", "Year" ,"RawRing"))
# # check duplication
# samples69_long[, .N, by = .(SampleID, Year)][N>1]
# # include RW_trt, this is the series that qa process works on,
# samples69_long[, RW_trt:= RawRing - shift(RawRing), by = SampleID]; label_trt <- "differentiated"
# acf.trt <- samples69_long[!is.na(RW_trt), .( ar1_trt = round(acf(RW_trt, plot = FALSE)$acf[2],2) ), by = .(SampleID)]
# # run quality assessment procedure
# qa.trt.ccf <-CFS_qa(dt.input = samples69_long)
# 
# spc.lst <- unique(tr_long$tr_3_trees$species)
# 
# dt.radii <- copy(qa.trt.ccf$dt.stats)
# dt.radii[, uid_radius:= as.integer(SampleID)]
# dt.radii <- merge(robj$tr_all_wide[,c("species", "uid_radius", "uid_site", "site_id", "uid_tree", "uid_sample")], dt.radii, by = "uid_radius")

N.nbs <- 10




report_spc <- function(tr_6ispc, tr_7ispc, min.nseries){
  if (nrow(tr_6ispc) >= min.nseries) {
    tr_7i<- copy(tr_7ispc)
    setnames(tr_7i, c("uid_radius", "year", "rw_mm"), c("SampleID", "Year" ,"RawRing"))
    # check duplication
    tr_7i[, .N, by = .(SampleID, Year)][N>1]
    # include RW_trt, this is the series that qa process works on,
    tr_7i[, RW_trt:= RawRing - shift(RawRing), by = SampleID]; label_trt <- "differentiated"
    acf.trt <- tr_7i[!is.na(RW_trt), .( ar1_trt = round(acf(RW_trt, plot = FALSE)$acf[2],2) ), by = .(SampleID)]
    # run quality assessment procedure
    qa.trt.ccf <-CFS_qa(dt.input = tr_7i, min.nseries = min.nseries)
    dt.radii.spc <- copy(qa.trt.ccf$dt.stats)
    dt.radii.spc[, uid_radius:= as.integer(SampleID)]
    # dt.radii.spc <- merge(tr_6ispc, dt.radii.spc, by = "uid_radius")

  }else {
    qa.trt.ccf <- list()
     dt.radii.spc <- tr_7ispc[, .(N = .N, rw.mean = mean(rw_mm), rw.sd = sd(rw_mm), rw.min = min(rw_mm), rw.max = max(rw_mm), ymin = min(year), ymax = max(year), ar1_rw = acf(rw_mm, plot = FALSE)$acf[2] ), by = .(uid_radius)]
if (nrow(tr_6ispc) > 10){
  # mean.rw <- tr_7i[, mean_rw:= mean(rw_mm), by = uid_radius]
  tmp <- merge(tr_7ispc, tr_7ispc[, .(mean_rw= mean(rw_mm)), by = year], by = "year")
  chk <- tmp[, .(ncorr_mean_rw = .N, result = cor.test(mean_rw, rw_mm)), by = .(uid_radius)]
 
  chk.corr <- chk[, .SD[4], by = uid_radius][, corr_mean_rw:= as.numeric(unlist(result))]

  chk.pvalue <- chk[, .SD[3], by = uid_radius][, pcorr_mean_rw:= as.numeric(unlist(result))]
  
  dt.radii.spc <- dt.radii.spc[chk.corr[, c("uid_radius", "corr_mean_rw", "ncorr_mean_rw")], on = "uid_radius"][chk.pvalue[, c("uid_radius", "pcorr_mean_rw")], on = "uid_radius"]
}
  }
  dt.radii.spc <- merge(tr_6ispc, dt.radii.spc, by = "uid_radius")
# dt.radii.spc <- dt.radii[species == spc.lst[i.spc]]
dt.summary.0 <- tr_6ispc[, .(lat = paste0(round(min(latitude),1), " ", round(max(latitude),1)),
                          lon = paste0(round(min(longitude),1), " ", round(max(longitude),1))), by = .(species)]

setnames(dt.summary.0, c("lat", "lon"), c("Latitude range", "Longitude range"))
dt.summary.0a <- melt(dt.summary.0, measure.vars = names(dt.summary.0), variable.name = "Category", value.name = "Value")





dt.summary.1 <- dt.radii.spc[, .(Yspan = paste0(min(ymin), " ", max(ymax)), Nsites = length(unique(uid_site)), Ntrees = length(unique(uid_tree)),
                                 Nsamples = length(unique(uid_sample)), N = .N,
                                 summ_rw = paste0(round(mean(rw.mean),2), " ± ", round(sd(rw.mean),2), " ( ", round(min(rw.min),2), ", ", round(max(rw.max),2), " )"),
                                 summ_len = paste0(round(mean(N),2), " ± ", round(sd(N),2), " ( ", round(min(N),2), ", ", round(max(N),2), " )"),
                                 summ_ar1 = paste0(round(mean(ar1_rw),2), " ± ", round(sd(ar1_rw),2), " ( ", round(min(ar1_rw),2), ", ", round(max(ar1_rw),2), " )"))]

dt.summary.1[, (names(dt.summary.1)) := lapply(.SD, as.character)]
setnames(dt.summary.1, c("Yspan","Nsites", "Ntrees", "Nsamples", "N", "summ_rw", "summ_len", "summ_ar1"), c("Year span", "Number of sites", "Number of trees", "Number of samples", "Number of series", "summary rw(mm)**", "summary len.series**", "summary AR1**"  ))

dt.summary.1a <- melt(dt.summary.1, measure.vars = names(dt.summary.1), variable.name = "Category", value.name = "Value")

dt.summary.2a <- rbind(dt.summary.0a, dt.summary.1a)

if (nrow(tr_6ispc) > min.nseries) {
dt.Npass<- data.table(Category = "Number of series (pass)*", Value = nrow(dt.radii.spc[qa_code == "pass"]), ord = 8.5 )} else{
  dt.Npass<- data.table(Category = "Number of series (pass)*", Value = "N.A.", ord = 8.5 )
  }
dt.summary.2a[, ord:=.I]
dt.summary.3a <- rbind(dt.summary.2a, dt.Npass)
setorder(dt.summary.3a, ord)
dt.summary.3a[,ord:=NULL]
# dt.summary.3a$species <- unique(tr_6ispc$species)
return(list(summary_spc = dt.summary.3a, qa.trt.ccf = qa.trt.ccf ))
}
```
```{r}


report_spc_site <- function(tr_6i, rw_ref, N.nbs){

dt.site <-tr_6i[,c("uid_site", "site_id",  "species", "latitude", "longitude", "uid_tree", "uid_sample", "uid_radius")]
dt.site.stats <- dt.site[, .(Ntrees = length(unique(uid_tree)), Nsamples = length(unique(uid_sample)), Nradius = .N), by = .(uid_site, site_id, longitude, latitude, species)]

dt.radii.spc <- dt.radii[species == spc.lst[i.spc]]

dt.site.summ <- dt.radii.spc[ ,.(
  summ_len = paste0(round(mean(N),2), " ± ", round(sd(N),2), " ( ", round(min(N),2), ", ", round(max(N),2), " )"),
  summ_rw = paste0(round(mean(rw.mean),2), " ± ", round(sd(rw.mean),2), " ( ", round(min(rw.min),2), ", ", round(max(rw.max),2), " )")), by = .(uid_site)]
# setnames(dt.site.stats, c("summ_rw", "summ_len"), c("summary rw(mm)**", "summary len.series**"))
dt.site.stats <- merge(dt.site.stats, dt.site.summ, by = "uid_site")
# head(dt.site.stats)
if (length(unique(dt.site.stats$uid_site)) < N.nbs + 2) {
  message("not sufficiant reference sites")
  dt.site.out <- dt.site.stats
  } else{
dt.scale.all <- data.table()
for (uid_site.i in dt.site.stats$uid_site){

  site.chk <- dt.site.stats[uid_site == uid_site.i ,c("species", "uid_site", "site_id", "latitude", "longitude")][, .SD[1]]

  dt.scale.i <- CFS_scale(site2chk = site.chk, ref_sites = rw_ref, N.nbs = N.nbs)$ratio.median
  dt.scale.all <- rbind(dt.scale.all, dt.scale.i)
  }
  

dt.site.out <- merge(dt.site.stats, dt.scale.all[, c("uid_site", "rw.median", "rw.median.nbs", "ratio_median")], all.x = TRUE,  by = "uid_site")
}
if (nrow(dt.site.out[!(Ntrees == Nradius)]) == 0) dt.site.out[, c("Nsamples", "Nradius") := NULL] else {
  if (nrow(dt.site.out[!(Nsamples == Nradius)]) == 0) dt.site.out[, c("Nradius") := NULL] else {
    if (nrow(dt.site.out[!(Nsamples == Ntrees)]) == 0) dt.site.out[, c("Nsamples") := NULL]
  }
}
return(dt.site.out)
}


rwl.all.trt <- CFS_format(data = list(rwl.all, 4:179), usage = 2)
  usage <- 1; robj <- rwl.all.trt
# robj <- params$robj
# usage <- params$usage
  tr_long <- robj$tr_all_long
  
 tr_w6 <- robj$tr_all_wide[, c("uid_site", "site_id", "uid_tree", "uid_sample",  "uid_radius", "radius_id", "rw_yend", "rw_ystart", "latitude", "longitude", "species", "dbh_cm", "ht_tot_m")]
tr_7 <- merge(tr_w6, tr_long$tr_7_ring_widths, by ="uid_radius")

spc.lst <- unique(tr_long$tr_3_trees$species)

label_trt <- "differentiated"
```

<br>
<br>

This report provides an overview of the dataset from the <b><u>`r tr_long$tr_1_projects$project_name`</u> </b> project, `r if (usage == 1)  "focusing on four key aspects:  
    1. Data Completeness: Assessment of missing or incomplete data.  (project)  
    2. Data Summary: Summary statistics and descriptive insights into the dataset.  (project-species)  
    3. site-level data summary and scale issues (site-species)  
    4. Correlation Analysis and quality assessment code: Evaluation of autocorrelation and correlation with the mean chronology for each series. It includes quality assessment codes generated by the CFS_qa() function.  (radii-species)  
  
The report aims to provide a comprehensive overview of the dataset's quality and characteristics, analyzed at the levels of species, species-site, and species-radius."` 

`r if (usage != 1)  "The report aims to visually present the dataset's quality and characteristics, summarized at both the species-project and species-site levels."`
`r if (usage == 1)  "<br><br>"`

`r if (usage == 1) "###  data completeness"`

`r if (usage == 1)  "<br>"`


`r if (usage == 1)  'This table presents the completeness of each variable of the whole dataset as a percentage. A value of 0 indicates no effective data. Please carefully verify that all required data has been included in the submission.'`
<br>

```{r,eval=usage == 1}
# library(gt)
# library(htmltools)
# if (usage != 1) return()
# Split the data into three blocks
split_dfs <- split(robj$complete_vars, cut(seq_len(nrow(robj$complete_vars)), breaks = 3, labels = FALSE))

# Generate gt tables
gt1_html <- gt(split_dfs[[1]]) %>% as_raw_html()
# %>%
# tab_header(title = "Block 1")
gt2_html <- gt(split_dfs[[2]]) %>% as_raw_html() 
# %>%
# tab_header(title = "Block 2")
gt3_html <- gt(split_dfs[[3]]) %>% as_raw_html() 


grid_layout <- tagList(
  tags$div(style = "display: grid; grid-template-columns: repeat(3, 1fr); gap: 20px;",
           tags$div(HTML(gt1_html)),
           tags$div(HTML(gt2_html)),
           tags$div(HTML(gt3_html))
  )
)

# Output the grid layout
grid_layout



```
  
`r if (usage == 1)  "<br><br>"`

###  data summary
`r if (usage == 1)  "<br>"`

`r if (usage == 1)  "This section presents key summary statistics, including spatial and temporal ranges, summary of ring width measurements, series length, etc. categorized by species. <br>"`
   
   
In this dataset, `r if (length(spc.lst) == 1) "there's" else "there're"` `r length(spc.lst)` species: **`r spc.lst`**

`r if (usage == 1)  "<br>"`

```{r, results='asis', warning=FALSE, message=FALSE, fig.width=10, fig.height=5, fig.align='left'}
library(knitr)
library(kableExtra)
library(gt)
library(patchwork)
library(ggplot2)
library(CFSTRenD)
# by species
qa<- vector("list", length(spc.lst))
for (i.spc in seq_along(spc.lst)){
# print(i.spc)
tr_6i <- tr_w6[species == spc.lst[i.spc]]
tr_7i <- tr_7[species == spc.lst[i.spc]]
# dt.radii.spc <- dt.radii[species == spc.lst[i.spc]]
# dt.summary.0 <- tr_6i[, .(lat = paste0(round(min(latitude),1), " ", round(max(latitude),1)), 
#                               lon = paste0(round(min(longitude),1), " ", round(max(longitude),1))), by = .(species)]
# 
# setnames(dt.summary.0, c("lat", "lon"), c("Latitude range", "Longitude range"))
# dt.summary.0a <- melt(dt.summary.0, measure.vars = names(dt.summary.0), variable.name = "Category", value.name = "Value")
# 
# 
# 
# 
# 
# dt.summary.1 <- dt.radii.spc[, .(Yspan = paste0(min(ymin), " ", max(ymax)), Nsites = length(unique(uid_site)), Ntrees = length(unique(uid_tree)), 
#                                  Nsamples = length(unique(uid_sample)), N = .N,
#                              summ_rw = paste0(round(mean(rw.mean),2), " ± ", round(sd(rw.mean),2), " ( ", round(min(rw.min),2), ", ", round(max(rw.max),2), " )"), 
#                              summ_len = paste0(round(mean(N),2), " ± ", round(sd(N),2), " ( ", round(min(N),2), ", ", round(max(N),2), " )"), 
#                              summ_ar1 = paste0(round(mean(ar1_rw),2), " ± ", round(sd(ar1_rw),2), " ( ", round(min(ar1_rw),2), ", ", round(max(ar1_rw),2), " )"))]
# 
# setnames(dt.summary.1, c("Yspan","Nsites", "Ntrees", "Nsamples", "N", "summ_rw", "summ_len", "summ_ar1"), c("Year span", "Number of sites", "Number of trees", "Number of samples", "Number of series", "summary rw(mm)**", "summary len.series**", "summary AR1**"  ))
# dt.summary.1a <- melt(dt.summary.1, measure.vars = names(dt.summary.1), variable.name = "Category", value.name = "Value")
# 
# dt.summary.2a <- rbind(dt.summary.0a, dt.summary.1a)
# 
# 
#   dt.Npass<- data.table(Category = "Number of series (pass)*", Value = nrow(dt.radii.spc[qa_code == "pass"]), ord = 8.5 )
#   dt.summary.2a[, ord:=.I]
#   dt.summary.3a <- rbind(dt.summary.2a, dt.Npass)
#   setorder(dt.summary.3a, ord)
#   dt.summary.3a[,ord:=NULL]


rpt.spc <- report_spc(tr_6i, tr_7i, min.nseries = 20)
  dt.summary.3a <- rpt.spc[[1]]
  # qa in a list
  if (length(rpt.spc[[2]]) > 0){
  # rpt.spc[[2]][[1]]$species <- spc.lst[i.spc]
  # rpt.spc[[2]][[2]]$species <- spc.lst[i.spc]
  qa[[i.spc]] <- rpt.spc[[2]]
  }
  
table_out <- dt.summary.3a %>%
  gt() %>%
  # tab_spanner(label = "Series", columns = everything()) %>%
  cols_align(
    align = "left",  # Align all columns to the left
    columns = everything()  # Apply to all columns
  ) %>%

# %>%
  tab_options(
    column_labels.hidden = TRUE,  # Hide the header
    table.border.top.style = "none",  # Remove top border
    table.border.bottom.style = "none",  # Remove bottom border
    # table_body.border.style = "none",  # Remove all horizontal lines
    table_body.hlines.style = "none",  # Remove horizontal lines between rows
    table_body.vlines.style = "none"  # Remove vertical lines between columns
  )
table_grob <- table_out %>% gt::as_gtable()

# Convert table_grob to a ggplot object
table_plot <- ggplot() + 
  annotation_custom(table_grob, xmin = 0, xmax = 1, ymin = 0, ymax = 1) + 
  theme_void() +
  theme(plot.margin = margin(2,20, 0,0))  # Add margin around the table


p.ispc<- plots_ds(list(tr_6i, tr_7i))



p.ispc <- p.ispc + 
  theme(plot.margin = margin(50, 50, 50, 50))
# Combine the table and plot side by side using patchwork with layout adjustments
final_output <- table_plot + p.ispc + 
 plot_layout(widths = c(1,1.5)) +
  plot_annotation() &
  theme(plot.margin = margin(5, 10, 5, 10))

# Display the combined output
# final_output

# print(final_output)
print(table_plot | p.ispc  + plot_layout(widths = c(1,20),heights = c(7,5)))

}
if (length(qa) > 0){
dt.stats <- rbindlist(lapply(qa, `[[`, 4), use.names = TRUE, fill = TRUE)

dt.stats[, uid_radius:= as.integer(SampleID)]

dt.radii <- merge(tr_w6[,c("species", "uid_radius", "uid_site", "site_id", "uid_tree",  "uid_sample", "radius_id")], dt.stats[, -"species"], all.x = TRUE, by = "uid_radius")
}else dt.radii <- tr_w6[,c("species", "uid_radius", "uid_site", "site_id", "uid_tree",  "uid_sample", "radius_id")]
```

  
 *Number of series that passed the test of CFS_qa() on `r label_trt` series  
 
**The values refer to mean ± sd (min, max)  




 <br>

###  site-level data summary
<br>
`r if (usage == 1)  "This section presents site-level data summaries, including a figure showing ring width measurements over time and a table with key statistics.<br>"`



```{r, results='asis', echo=FALSE, warning=FALSE, message=FALSE, fig.width=12, fig.height=5, fig.align='left'}  

# plot rw by site_id
library(ggplot2)
library(ggforce)

for (i.spc in seq_along(spc.lst)){
  
  
dt.radii.spc <- dt.radii[species == spc.lst[i.spc]]
# dt.radii[, year:= as.numeric(year)]
# plotting 
tr_7i <- tr_7[species == spc.lst[i.spc]]

plot_list <- plots_facet(data = tr_7i, varcols = c("year", "rw_mm", "site_id"), xylabels = c("Year", "Ring Width (mm)"), nrow = 1, ncol = 2)
# plot_list[[4]] <- NULL
library(patchwork)

cat(paste("\n\n"))
cat(paste("#####", spc.lst[i.spc], "on ring width measurement", "\n\n"))
print(length(plot_list))
for (page in 1:ceiling(length(plot_list) / 2)) {
  if (2 * page <= length(plot_list)) {
    # Print two plots per page
    # print(plot_list[[2 * page - 1]] | plot_list[[2 * page]] +
    #         plot_annotation() &
    #         theme(plot.margin = margin(5, 5, 5, 5)))
    print(wrap_plots(plot_list[[2 * page - 1]], plot_list[[2 * page ]], ncol = 2) +
  plot_annotation() &
  theme(plot.margin = margin(5, 5, 5, 5))
)  } else {
    # Print the last plot alone when there's an odd number of plots
    print(plot_list[[2 * page - 1]] + 
            plot_annotation() &
            theme(plot.margin = margin(5, 5, 5, 5)))
  }
}

if (usage != 1){
 
tr_7i <- cal.bai(tr_7i, "uid_tree" , "rw_mm")
plot_list <- plots_facet(data = tr_7i, varcols = c("year", "bai_cm2", "site_id"), xylabels = c("Year", "basal area increment (cm2)"), nrow = 3, ncol = 2)
# 
#  empty_plot <- ggplot() +
#   theme(
#     panel.background = element_blank(),  # No background
#     plot.background = element_blank(),   # No plot area background
#     axis.ticks = element_blank(),        # No axis ticks
#     axis.text = element_blank(),         # No axis text
#     axis.title = element_blank()         # No axis titles
#   )
# 
# # print(empty_plot)
# 
# if ((floor(total_pages/2))*2 != total_pages) plot_list[[total_pages+1]] <- empty_plot
library(patchwork)
cat(paste0("<br><br>"))
cat(paste(" \n\n\n\n"))


cat(paste("#####", spc.lst[i.spc], "on basal area increment", "\n\n"))

# normal distribution
# p.bai <- ggplot(tr_7i, aes(x = bai_cm2)) +
#   geom_histogram(aes(y = after_stat(density)),  # Use density for scaling
#                  binwidth = 1, color = "black", fill = "#A9D08E") +
#   stat_function(fun = dnorm, args = list(
#     mean = mean(tr_7i$bai_cm2, na.rm = TRUE),
#     sd = sd(tr_7i$bai_cm2, na.rm = TRUE)
#     ),
#                 color = "red", linetype = "dashed", size = 1) +
#   labs(title = "bai (cm2)",
#        x = "bai (cm2)",
#        y = "Density") +
#   theme_classic()

# # Fit gamma parameters to your data
# gamma_params <- MASS::fitdistr(tr_7i$bai_cm2[tr_7i$bai_cm2 > 0], "gamma")
# 
# shape <- gamma_params$estimate["shape"]
# rate <- gamma_params$estimate["rate"]
# 
# # Create the plot with gamma distribution
# p.bai <- ggplot(tr_7i, aes(x = bai_cm2)) +
#   geom_histogram(aes(y = after_stat(density)),  # Use density for scaling
#                  binwidth = 1, color = "black", fill = "#A9D08E") +
#   stat_function(fun = dgamma, args = list(
#     shape = shape,
#     rate = rate
#     ), color = "red", size = 1) +  # Add gamma function with customizations
#   labs(
#     title = "Histogram on BAI with Gamma Distribution Fit",
#     x = "BAI (cm²)",
#     y = "Density"
#   ) +
#   theme_minimal()
# 
# 
# p.log_bai <- ggplot(tr_7i, aes(x = log(bai_cm2))) +
#   geom_histogram(aes(y = after_stat(density)),  # Use density for scaling
#                  binwidth = 1, color = "black", fill = "#A9D08E") +
#   stat_function(fun = dnorm, args = list(
#     mean = mean(log(tr_7i$bai_cm2), na.rm = TRUE),
#     sd = sd(log(tr_7i$bai_cm2), na.rm = TRUE)
#     ),
#                 color = "red", linetype = "dashed", size = 1) +
#   labs(title = "Histogram on log-BAI with Normal Distribution Fit",
#        x = "log-bai",
#        y = "Density") +
#   theme_classic()


# p.bai|p.log_bai
cat(paste0("length of plot_list: ", length(plot_list)))
for (page in 1:ceiling(length(plot_list) / 2)) {
  if (2 * page <= length(plot_list)) {
    # Print two plots per page
    print(plot_list[[2 * page - 1]] | plot_list[[2 * page]] +
            plot_annotation() &
            theme(plot.margin = margin(5, 5, 5, 5)))
  } else {
    # Print the last plot alone when there's an odd number of plots
    print(plot_list[[2 * page - 1]] + 
            plot_annotation() &
            theme(plot.margin = margin(5, 5, 5, 5)))
  }
}

# print species level bai and log-bai
# cat(paste0("<br><br>"))
# cat("\n\n\n\n")
# 
# cat(paste("#####", spc.lst[i.spc], "on bai and log(bai)", "\n\n"))
# print(p.bai|p.log_bai  + plot_layout(widths = c(1,1)))
}

}

if (usage != 1){
  
  # Fit gamma parameters to your data
  tr_7 <- cal.bai(tr_7, "uid_tree" , "rw_mm")
gamma_params <- MASS::fitdistr(tr_7$bai_cm2[tr_7$bai_cm2 > 0], "gamma")

shape <- gamma_params$estimate["shape"]
rate <- gamma_params$estimate["rate"]

# Create the plot with gamma distribution
p.bai <- ggplot(tr_7, aes(x = bai_cm2)) +
  geom_histogram(aes(y = after_stat(density)),  # Use density for scaling
                 binwidth = 1, color = "black", fill = "#A9D08E") +
  stat_function(fun = dgamma, args = list(
    shape = shape,
    rate = rate
    ), color = "red", size = 1) +  # Add gamma function with customizations
  labs(
    title = "Histogram on BAI with Gamma Distribution Fit",
    x = "BAI (cm²)",
    y = "Density"
  ) +
  theme_minimal()


p.log_bai <- ggplot(tr_7, aes(x = log(bai_cm2))) +
  geom_histogram(aes(y = after_stat(density)),  # Use density for scaling
                 binwidth = 1, color = "black", fill = "#A9D08E") +
  stat_function(fun = dnorm, args = list(
    mean = mean(log(tr_7[bai_cm2 > 0]$bai_cm2), na.rm = TRUE),
    sd = sd(log(tr_7[bai_cm2 > 0]$bai_cm2), na.rm = TRUE)
    ),
                color = "red", linetype = "dashed", size = 1) +
  labs(title = "Histogram on log-BAI with Normal Distribution Fit",
       x = "log-bai",
       y = "Density") +
  theme_classic()
cat(paste0("<br><br>"))
cat("\n\n\n\n")

cat(paste("#####", "on bai and log(bai)", "\n\n"))
print(p.bai|p.log_bai  + plot_layout(widths = c(1,1)))
}

``` 



`r if (usage == 1) paste0("<br><br>This table provides a site-level summary, including the series length, raw ring width measurements, the median ring width, the median ring width of its", N.nbs, " closest neighbors, and the ratio between them. This offers insights into potential outliers caused by scaling issues. <br><br>")`

```{r, results='asis', echo=FALSE, message=FALSE, warning=FALSE, eval= usage == 1, warning=FALSE, fig.width=10, fig.height=5, fig.align='left'}  


for (i.spc in seq_along(spc.lst)){
  print(i.spc)
  tr_6i <- tr_w6[species == spc.lst[i.spc]]
  rw_ref <- rwl.all.trt$tr_all_wide[species == spc.lst[i.spc]]
  
  dt.site.out <- suppressMessages(report_spc_site(tr_6i, rw_ref, N.nbs = 5))
  if ("Nradius" %in% names(dt.site.out)) setnames(dt.site.out, "Nradius", "Nb. radiuses")
  if ("Nsamples" %in% names(dt.site.out)) setnames(dt.site.out, "Nsamples", "Nb. samples")
  
  setnames(dt.site.out, c("latitude", "longitude", "Ntrees",   "summ_rw", "summ_len"),
           c("lat", "lon", "Nb. trees",   "rw(mm)**", "len.series**"))
  
  if (all(c( "rw.median", "rw.median.nbs", "ratio_median") %in% names(dt.site.out)))
  setnames(dt.site.out, c( "rw.median", "rw.median.nbs", "ratio_median"),
           c( "median rw(mm)", "neigh median rw(mm)", "ratio_rw*"))
  
  # dt.site.out %>%
  # kable(format = "html") %>%  # Change format to "html"
  #   kable_styling(
  #     bootstrap_options = NULL,  # No bootstrap options
  #     latex_options = NULL,      # Remove LaTeX options (not applicable to HTML)
  #     stripe_color = "red",
  #     stripe_index = 1,
  #     full_width = FALSE,
  #     position = "left"
  #   ) %>%
  #    row_spec(0, bold = TRUE)  # Makes header bold, optional
  
  # dt.site.out %>%
  #   gt() %>%
  #   # tab_header(
  #   #   title = "Scrollable Data Table"
  #   # ) %>%
  #   tab_style(
  #     style = list(
  #       cell_borders(sides = c("top", "bottom"), color = "gray", weight = 1)
  #     ),
  #     locations = cells_body()
  #   ) %>%
  #   as_raw_html() %>%
  #   # {paste0('<div style="overflow-x: auto; max-width: 100%; height: 300px;">', ., '</div>')} %>%
  #   browsable()  # This forces the HTML to be properly rendered
  # as_raw_html() %>%
  # {paste0('<div style="overflow-x: auto; max-width: 100%; height: 300px;">', ., '</div>')}
  
  # dt.site.out %>%
  #   kable(format = "html") %>%
  #  kable_styling(
  #   full_width = FALSE,
  #   position = "left"
  # )
  
  # gt1_html <- gt(dt.site.out) %>% as_raw_html()
  #  print(gt1_html)
  # grid_layout <- tagList(
  #   tags$div(style = "display: grid; grid-template-columns: 1fr; gap: 20px;",
  #            tags$div(HTML(gt1_html)))
  #   )
  # grid_layout
  
  gt_table <- gt(dt.site.out) %>%
    tab_header(title = spc.lst[i.spc]) %>%
    tab_style(
      style = cell_text(weight = "bold"),  # Set header text to bold
      locations = cells_column_labels(everything())  # Apply style to all headers
    ) %>%
    cols_align(
      align = "center", # Center align content
      columns = everything() # Apply to all columns
    )%>%
    #  cols_width(
    #   everything()[7] ~ pct(8),         # First column: 20% width
    #   everything()[8] ~ pct(12),        # Second column: 30% width
    #   everything()[9] ~ pct(12)         # Third column: 50% width
    # )%>%
    tab_options(
      table.width = "100%",
      heading.title.font.weight = "bold",  # Make the header bold
      table.border.top.width = px(0),
      table_body.border.top.width = px(0),
      table_body.border.bottom.width = px(0)
    )
  
  # Add scrolling through CSS
  scrollable_table <- htmltools::div(
    gt_table %>% as_raw_html(),
    style = "overflow-y: auto; height: 400px; border: 1px solid #ddd; padding: 10px;"
  )
  
  # scrollable_table
  # Print the table
  print(scrollable_table, browse = FALSE)  # Render the scrollable table
  rm(gt_table, scrollable_table)
  # cat("<br><br>")
}


```
  
<br>


`r if (usage == 1) paste0(" *ratio between median of rw of the site and median of rw of its ", N.nbs, " nearest neighbors. ")` 
  
`r if (usage == 1) "**The values refer to mean ± sd (min, max)" `
  
<br>
<br>    


`r if (usage == 1) "###  Correlation and quality assessment code"`
<br>

`r if (usage == 1) paste0("This table provides a summary for each series, including raw ring width measurements, autocorrelation, correlation with master chronology for both raw and ", label_trt, " data, and quality assessment code (qa_code) which was derived from the CFS_qa() function. The master chronology includes all the series with qa_code 'pass'.")`

<br>




```{r, results='asis', eval= usage == 1, warning=FALSE, fig.width=10, fig.height=5, fig.align='left'}  
# names(dt.radii)
for (i.spc in seq_along(spc.lst)){

  

dt.radii.spc <- dt.radii[species == spc.lst[i.spc]]

# dt.radii.spc[, summ_rw := paste0(round(rw.mean,2), " ± ", round(rw.sd,2), " ( ", round(rw.min,2), ", ", round(rw.max,2), " )")]
dt.radii.spc[,summ_corr_rw:= paste0(round(corr_mean_rw,2), " ( ", ncorr_mean_rw, ", ", round(pcorr_mean_rw,2), " )") ]
dt.radii.spc[,summ_corr_trt:= paste0(round(corr_mean_trt,2), " ( ", ncorr_mean_trt, ", ", round(pcorr_mean_trt,2), " )") ]
dt.radii.spc[, ar1_rw:=round(ar1_rw, 2)]
dt.radii.spc.stats <- dt.radii.spc[, c("uid_site", "uid_radius", "ymin", "ymax", "N", "ar1_rw", "summ_corr_rw","ar1_trt",  "summ_corr_trt", "qa_code")]
  setnames(dt.radii.spc.stats, c("ymin", "ymax", "N",  "ar1_rw", "ar1_trt", "summ_corr_rw", "summ_corr_trt", "qa_code"), c("year from", "year to", "len series",  "raw AR1*", "trt AR1**", "raw corr_mean*&", "trt corr_mean**&", "qa_code**%"))
setorder(dt.radii.spc.stats, uid_radius) 

# dt.radii.spc.stats %>%
#   kable(format = "html") %>%
#   kable_styling(bootstrap_options = NULL,  # No bootstrap options
#                 latex_options = "hold_position",
#                 stripe_color = "red",
#                 stripe_index = 1,
#                 full_width = FALSE,
#                 position = "left") %>%
# 
#   scroll_box(height = "500px", fixed_thead = TRUE)%>%
#    row_spec(0, bold = TRUE)  # Makes header bold, optional

gt_table <- gt(dt.radii.spc.stats) %>%
  tab_header(title = spc.lst[i.spc]) %>%
 tab_style(
    style = cell_text(weight = "bold"),  # Set header text to bold
    locations = cells_column_labels(everything())  # Apply style to all headers
  ) %>%
  cols_align(
    align = "center", # Center align content
    columns = everything() # Apply to all columns
  )%>%
  # cols_width(
  #     everything()[1] ~ pct(7),
  #     everything()[2] ~ pct(10),
  #   everything()[3] ~ pct(5),         # First column: 20% width
  #   everything()[4] ~ pct(5),
  #   everything()[5] ~ pct(6),
  #   everything()[7] ~ pct(7),
  #   everything()[9] ~ pct(7),
  #   everything()[11] ~ pct(10)# Third column: 50% width
  # )%>%
  tab_options(
    table.width = "100%",
    heading.title.font.weight = "bold",  # Make the header bold
    table.border.top.width = px(0),
    table_body.border.top.width = px(0),
    table_body.border.bottom.width = px(0)
  )

# Add scrolling through CSS
scrollable_table <- htmltools::div(
  gt_table %>% as_raw_html(),
  style = "overflow-y: auto; height: 400px; border: 1px solid #ddd; padding: 10px;"
)

# Print the table
print(scrollable_table, browse = FALSE)  # Render the scrollable table
rm(gt_table, scrollable_table)
# cat("<br><br>")
}
```
 
<br>
`r if (usage == 1) "  *developed  from raw series"`  
   
`r if (usage == 1) paste0(" **developed  from ",  label_trt, " series")`
   
`r if (usage == 1) " &correlation with master chronology, the value represents correlation (N, p-value) "`  

`r if (usage == 1) " %qa_code is identified using the current data as reference dataset "` 



 

